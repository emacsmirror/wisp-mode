#+title: Why Wisp?
#+options: num:nil toc:nil
# Export as s5 presentation. See http://orgmode.org/worg/org-tutorials/non-beamer-presentations.html

#+BEGIN_SRC elisp :exports none
(require 'ox-s5)
#+END_SRC

* Elegance
#+html: <br />
** *.,":'_#?!;*

/The most common non-letter, non-math characters in prose/

** *()*

/The most common paired characters/

(From letter distributions in newspapers)

* On Words                                           

#+BEGIN_SRC elisp :exports results :results results raw
  (defun shuffle-wordcontent (string)
    (interactive)
    (let ((strings (split-string string)))
      (substring 
       (apply 'concat 
              (loop for s in strings 
                    collect (if (< (length s) 4) 
                                (concat s " ")
                              (concat (substring s 0 1) 
                                      (apply 'concat 
                                             (mapcar 'string 
                                                     (shuffle-vector 
                                                      (string-to-vector 
                                                       (substring s 1 -1)))))
                                      (substring s -1)
                                      " "))))
       0 -1)))
  
  (concat "*" (setq why-wisp-text-scheme-has (shuffle-wordcontent "Scheme follows a minimalist design philosophy")) "*")
#+END_SRC

#+RESULTS:
*Shcmee fowlols a malisimint dsegin plhpoihosy*

- /Defocus a bit/
- /Can you see the meaning?/

* Scheme for Newcomers

#+BEGIN_SRC elisp :exports results :results results raw
  (concat "*€" (combine-and-quote-strings (split-string why-wisp-text-scheme-has) " €") (apply 'concat (loop for word in (split-string why-wisp-text-scheme-has) collect "¥") ) "*")
#+END_SRC

#+RESULTS:
*€Shcmee €fowlols €a €malisimint €dsegin €plhpoihosy¥¥¥¥¥¥*

- /Try it again/
- /Do you see how much harder it got?/
- /€ and ¥ escape your existing filters/


* Summary

1. Lisp uses the *most common* non-letter characters.
2. The *first and last characters* are important for text-recognition.

Let’s call these elegance 1 and elegance 2.

Any fix for elegance 2 should preserve elegance 1.

Elegance 0: generality and homoiconicity: *code is data*.

* On Wisp
#+html: <br />
#+BEGIN_SRC scheme
  define : hello
           display "Hello Schemers!\n"
#+END_SRC

becomes

#+BEGIN_SRC scheme
  (define (hello)
          (display "Hello Schemers!\n"))
#+END_SRC

* Why not SRFI-49 (Indentation-sensitive syntax)?

** Scheme

#+BEGIN_SRC scheme
  (+ 5 
     (* 4 3) 
     2 1 0)
#+END_SRC

** SRRFI-49 (Indentation-sensitive syntax)

#+BEGIN_SRC scheme
  + 5
    * 4 3
    2
    1
    0
#+END_SRC

* Continuing the argument list in wisp

#+BEGIN_SRC scheme
  + 5
    * 4 3
    . 2 1 0
#+END_SRC

/Complete representation of arbitrary structures/

* Why no SRFI-110 (Sweet-expressions (t-expressions))

#+BEGIN_SRC scheme
myfunction 
  x: \\ original-x
  y: \\ calculate-y original-y
#+END_SRC

#+BEGIN_SRC scheme
  a b $ c d e $ f g
#+END_SRC

#+BEGIN_SRC scheme
  let <* x getx() \\ y gety() *>
  ! {{x * x} + {y * y}}
#+END_SRC

/This breaks elegance 1/

/Also the problems of SRFI-49 are preserved/
