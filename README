Wisp: Whitespace to Lisp
========================

    define : hello                    (define (hello)
      display "Hello World"     ⇒        (display "Hello World"))


    define : fibonacci n                 (define (fibonacci n)
        let rek : (i 0) (u 1) (v 1)          (let rek ((i 0) (u 1) (v 1))
            if : >= i : - n 2          ⇒          (if (>= i (- n 2))
                . v                                    v
                rek (+ i 1) v (+ u v)                 (rek (+ i 1) v (+ u v)))))


Wisp turns indentation based syntax into Lisp. The conversion is homoiconic[^h], generic[^g], and backwards-compatible[^b]. It is inspired by project readable, but tries to keep itself simple (and stupid: just a preprocessor). More information on the [wisp-website][] and code in the [wisp-repository][].

[wisp-website]: http://draketo.de/light/english/wisp-lisp-indentation-preprocessor
[wisp-repository]: http://draketo.de/proj/wisp

Requirements
------------

* [Python 3.x][] to bootstrap wisp
* [GNU Guile 2.x][] for running it

[Python 3.x]: http://python.org "Python Programming Language"
[GNU Guile 2.x]: http://gnu.org/s/guile "GNU Guile: The official extension language for the GNU operating system."

Usage
-----

* Get wisp: `hg clone http://draketo.de/proj/wisp`
* Bootstrap: `autoreconf -i && ./configure && make`
* Preprocess files: `guile ./wisp.scm infile.wisp > outfile.scm`
* Wisp at the REPL: `guile -L . --language=wisp # run this in the wisp-folder`

Wisp and curly infix (SRFI-105)
-------------------------------

Wisp treats braces "{}" the same as parentheses "()" and square brackets "[]", so it is compatible with curly infix ([SRFI-105](http://srfi.schemers.org/srfi-105/srfi-105.html)) to get more customary math expressions. In Guile Scheme with Wisp you can activate curly infix using the following line `. #!curly-infix ` (mind the final space!)

The fibonacci-example above can then be transformed to the following:

    . #!curly-infix 
    define : fibonacci n
        let rek : (i 0) (u 1) (v 1)
            if {i >= {n - 2}}
                . v
                rek {i + 1} v {u + v}

If you want to use a curly-infix expression starting a line, you have to prefix it with a dot:

    . {1 + 1}
    ; = 2

Notes
-----

Copyright: 2013--2014 Arne Babenhauserheide

License: GPLv3 or later


[^h]: Wisp is homoiconic because everything you write gets turned into lisp which is homoiconic.

[^g]: Wisp is generic, because it works for any language which uses brackets to start a function call - which is true for most lisps. You simply get rid of the speerwall of parentheses without losing their power.

[^b]: Wisp is backwards compatible, because you can simply use arbitrary lisp code in wisp: Indentation processing skips expressions in brackets.
